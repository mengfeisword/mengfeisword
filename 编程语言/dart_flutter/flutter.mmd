Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# flutter

## 简介
> leftSide=`true`


### 基本原理和原生比较的优劣势

## 学习资料
> leftSide=`true`


### flutter官网

### github

### flutter中文网

## 编译打包

### 常用命令

### 混淆

## 用户界面
> leftSide=`true`


### 动画

### 布局，基础控件

### 路由和导航

### 手势

### 字体，资源和图片

## 项目架构

### 架构模式

### 基础构建\(命名\)

### 组件化

## 包和插件
> leftSide=`true`


### 使用插件

### 插件开发

### 与原生交互

## 使用Flutter

### 安装和环境配置

#### Windows

#### macOS

#### Linux

### 编辑工具

#### 工具

##### VS Code

##### 基于idea

##### 基于Andriod Studio

#### 插件

##### flutter

##### dart

### 体验

#### 运行

#### 热重载\(hot reload\)

#### 模式

##### debug

##### release

##### profile

### 其他经验

#### Andriod

#### IOS

#### React Native

#### Web

#### Xamarin

#### 声明式UI

### dart语言

### 构建Web应用

## 测试和调试
> leftSide=`true`


### 调试工具

#### 开发者工具\(DevTools\)

#### Android Studio/IntelliJ 和 VS Code（借助 Flutter 和 Dart 插件

#### Flutter inspector

### 编程方式

#### Logging

#### 设置断点

#### Debug flags

#### Widget tree

#### Render tree

#### Layer tree

#### Semantics tree

#### Scheduling

#### Debug flags: layout

#### Debugging animations

#### Debug flags: performance

#### Tracing Dart code performance

#### Performance overlay

#### Widget alignment grid

### 原生的调试器

#### Dart 调试器

#### Flutter inspector

#### Flutter outline

### 构建模式

#### Debug
- NOTE
<pre>Debug 模式意味着：
断点 是开启的。
服务扩展是开启的。
针对快速开发和运行周期进行了编译优化（但不是针对执行速度、二进制文件大小或者部署）。
调试开启，类似 开发者工具 等调试工具可以连接到进程里。</pre>

##### 热重载功能

##### 仿真器和模拟器运行

#### Release
- NOTE
<pre>使用 Release 模式意味着：
断点是不可用的。
调试信息是不可见的。
调试是禁用的。
编译针对快速启动、快速执行和小的 package 的大小进行了优化。
服务扩展是禁用的。</pre>

##### 发布应用

#### Profile
- NOTE
<pre>profile 模式和 release 类似，但有以下不同：
一些服务扩展是启用的。例如，支持 performance overlay。
Tracing 是启用的，一些调试工具，比如 开发者工具 可以连接到进程里。

在 Web 平台的 Profile 模式意味着：
资源文件没有被压缩，但是整体性能已经优化
这个 Web 应用通过 dart2js 编译器构建</pre>

##### 分析性能

#### headless

##### 测试

### 处理错误

### 测试

#### 单元测试
- NOTE
<pre>本教程将会为大家演示 test package 的用法，内容如下：
将 test 或者 flutter_test加入依赖；
创建测试文件；
创建一个要测试的类；
为创建的类写一个测试；
整合多个测试到一个 group；
执行测试。
使用单元测试可轻松地验证单个函数、方法或类的行为。test 包提供了写单测的核心框架， flutter_test 包则提供了额外的功能来测试 Widget。</pre>

##### 1\.添加测试依赖
- NOTE
<pre>如果 Dart 包没有依赖 Flutter，可以导入 test 包。Test 包提供了编写测试所需要的核心功能。当我们写的包需要被 web、服务端和 Flutter app 使用时，这是最佳的方式。
content_copy
dev_dependencies:
  test: &lt;latest_version&gt;</pre>

##### 2\. 创建测试文件
- NOTE
<pre>本例中，我们会创建两个文件：counter.dart 和 couter_test.dart。

counter.dart 文件包含一个位于 lib 文件夹的待测试类,而位于 test 文件夹的counter_test.dart 文件将包含测试本身，。

通常测试文件应位于放置在 Flutter 应用或包的根目录下的 test 文件夹。

In general, test files should reside inside a test folder located at the root of your Flutter application or package.

创建完成后，文件目录结构如下：

content_copy
counter_app/
  lib/
    counter.dart
  test/
    counter_test.dart</pre>

##### 3\. 创建一个要测试的类
- NOTE
<pre>我们需要一个“单元”来测试。记住：“单元”是一个抽象的名称，它可以表示一个函数、方法或者类。本例中，我们会在 lib/counter.dart 文件中创建一个 Counter 类。它负责增加或减少一个从 0 开始的 value。

content_copy
class Counter {
  int value = 0;

  void increment() =&gt; value++;

  void decrement() =&gt; value--;
}</pre>

##### 4\. 为创建的类写一个测试
- NOTE
<pre>我们将在 counter_test.dart 文件中写第一个测试。使用顶级函数 test 来定义，可通过执行顶级函数 expect 来检查结果正确与否。这两个函数都来自 test 这个 package。

content_copy
// Import the test package and Counter class
import 'package:test/test.dart';
import 'package:counter_app/counter.dart';

void main() {
  test('Counter value should be incremented', () {
    final counter = Counter();

    counter.increment();

    expect(counter.value, 1);
  });
}</pre>

##### 5\. 整合多个测试到一个 group
- NOTE
<pre>如果多个测试之间互相关联，可以使用 test 这个 package 提供的 group 函数将他们整合到一起。

content_copy
import 'package:test/test.dart';
import 'package:counter_app/counter.dart';

void main() {
  group('Counter', () {
    test('value should start at 0', () {
      expect(Counter().value, 0);
    });

    test('value should be incremented', () {
      final counter = Counter();

      counter.increment();

      expect(counter.value, 1);
    });

    test('value should be decremented', () {
      final counter = Counter();

      counter.decrement();

      expect(counter.value, -1);
    });
  });
}</pre>

##### 6\. 执行测试

#### Widget 测试

#### 集成测试

#### 持续集成服务

## 性能优化

### 性能评估

#### 包大小

##### 减少大小

###### 删除未使用的资源

###### 最小化从库导入的资源

###### 支持有限数量的屏幕密度

###### 压缩PNG和JPEG文件

#### 渲染性能

##### 性能优化

###### 控制 build\(\) 方法的耗时
- NOTE
<pre>Controlling build() cost
避免在 build() 方法中进行重复且耗时的工作，因为当父 widget 重建时，子 Wdiget 的 build() 方法会被频繁地调用。

避免在一个超长的 build() 方法中返回一个过于庞大的 widget。把他们分拆成不同的 widget，并进行封装，另外他们要这样改变：

当在 State 上调用 setState()时，所有后代 widget 都将重建。因此，将 setState() 的调用转移到其 UI 实际需要更改的 widget 子树部分。如果改变的部分仅包含在 widget 树的一小部分中，请避免在 widget 树的更高层级中调用 setState()。

当重新遇到与前一帧相同的子 widget 实例时，将停止遍历。这种技术在框架内部大量使用，用于优化动画不影响子树的动画。请参阅 [TransitionBuilder][] 模式和使用此原则的 [SlideTransition][]，以避免在动画过程中重建其后代 widget。

另见：

Statefulwidget API 文档的 Performance considerations 部分。</pre>

###### 仅当需要的时候才应用效果
- NOTE
<pre>一些在使用效果时的通用规则：

能不用 Opacity widget，就尽量不要用。有关将透明度直接应用于图像的示例，请参见 Transparent image，这比使用 Opacity widget 更快。

Clipping 不会调用 saveLayer()（除非明确使用 Clip.antiAliasWithSaveLayer），因此这些操作没有 Opacity 那么耗时，但仍然很耗时，所以请谨慎使用。

其他会触发 saveLayer() 的 widget，可能也会代价高昂。

ShaderMask
ColorFilter
Chip— 当 disabledColorAlpha != 0xff 的时候，会调用 saveLayer()

Text—might cause call to saveLayer() if there’s an overflowShader
Text— 当有 overflowShader 时，会调用saveLayer()

避免调用 saveLayer() 的方式：

要在图像中实现淡入淡出，请考虑使用 FadeInImage widget，该 widget 使用 GPU 的片段着色器应用渐变不透明度。了解更多详情，请参见 Opacity 文档。

要创建带圆角的矩形，而不是应用剪切矩形，请考虑使用很多 widget 都提供的 borderRadius属性。</pre>

###### 对列表和网格列表懒加载
- NOTE
<pre>在构建大型网格或列表时，使用带有回调的惰性方法。这样，只有屏幕的可见部分是在开始时构建的。

请参阅：

实用教程里的 长列表的处理 文档

来自社区的 AbdulRahman AlHamali 撰写的 Creating a ListView that loads one page at a time

Listview.builder API</pre>

###### 在 16ms 内渲染完成每一帧
- NOTE
<pre>由于构建和渲染有两个独立的线程，因此构建时间为 16ms，60Hz 显示器上渲染时间为 16ms。如果需要考虑延迟，就要在 16ms 或更短 的时间内构建和显示帧。请注意，这意味着构建需要少于 8ms，渲染也需要少于 8ms，总计 16ms 或更短。如果需要考虑丢帧（jankyness），那么每个构建和渲染阶段的 16ms 都可以。

如果在 profile 构建 状态下，每一帧渲染时间低于 16ms，你可能不必担心性能问题以及一些性能陷阱，但仍然应该致力于尽可能快地渲染每一帧。为什么？

将帧渲染时间降低到 16ms 以下可能在视觉上看不出来什么变化，但可以延长电池寿命以及避免发热问题。

可能在你当前测试设备上运行良好，但请考虑在应用所支持的最低端设备上的情况。

当 120fps 的设备普及之后，便需要在 8ms 之内完成每一帧的渲染来保证流畅平滑的体验。</pre>

###### 陷阱
- NOTE
<pre>如果你需要调整应用程序的性能，或者 UI 顺畅度没达到你的预期，那么 IDE 的 Flutter plugin 可以提供帮助。在 Flutter Performance 窗口中，勾选 Show widget rebuild information 复选框。此功能可帮助你检测帧的渲染和显示时间是否超过 16ms。在可能的情况下，插件提供指向相关提示的链接。

以下行为可能会对您应用的性能产生负面影响。

避免使用 Opacity widget，尤其是在动画中避免使用。请用 AnimatedOpacity 或 FadeInImage 进行代替。更多信息，请参阅 Performance considerations for opacity animation。

使用 AnimatedBuilder 时，请避免在不依赖于动画的 widget 的构造方法中构建 widget 树。动画的每次变动都会重建这个 widget 树。而应该构建子树的那一部分，并将其作为 child 传递给 AnimatedBuilder。更多内容，请查看 这个文档。

避免在动画中剪裁。如果可能，请在动画开始之前预先剪切图像。

如果大多数 children widget 在屏幕上不可见，请避免使用返回具体列表的构造函数（例如 Column() 或 ListView()），以避免构建成本。</pre>

## 打包部署

### 配置 flavors 构建双端

### 打包并发布 Android 应用

### 打包并发布 iOS 应用

### 打包并发布 Web 应用

### 持续部署
