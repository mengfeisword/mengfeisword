Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Dart语法
> align=`right`


## 类

### Dart是一种面向对象的语言，一切皆对象。支持面向对象的编程功能，如类，接口等

### 所有类有同一个基类\-Object，dart的继承使用了Mixin机制

### 构造方法

#### 默认构造方法

#### 命名构造方法 Class name\(var param\)

#### 调用父类构造方法

#### 不可变对象，定义编译时常量对象，构造函数前加const

#### 工厂构造函数：factory

#### 如果对象为final或者const的话，只有一个getter方法     Getter、Setter

#### 抽象类

### 类的语法
- NOTE
<pre>class class_name {                  //类名
   &lt;fields&gt;                                 //字段是类中声明的任何变量。字段表示与对象有关的数据。
   &lt;getters/setters&gt;                    //允许程序初始化和检索类字段的值。默认的getter/setter与每个类相关联。但是，可以通过显式定义setter/getter来覆盖默认值。
   &lt;constructors&gt;                       //负责为类的对象分配内存。
   &lt;functions&gt;                            //函数表示对象可以采取的操作。它们有时也被称为方法。
}</pre>

### this关键字指向类的当前实例

### getter和setter方法

### 类继承

#### 一个类使用extends关键字从另一个类继承

#### Dart不支持多重继承

#### 类继承和方法重写：@override

### static关键字：静态变量保留其值，直到程序完成执行

### super关键字：super关键字用来指一类的直接父类

## 函数

### 定义：特定任务的执行方式和方式
- NOTE
<pre>函数定义指定特定任务的执行方式和方式。在使用函数之前，必须先定义它。定义标准函数的语法如下
function_name() {  
   //statements      
}
要么
void function_name() {
   //statements
}
该 void 关键字表明函数没有任何值返回给调用者。</pre>

### 调用：调用函数才能执行它
- NOTE
<pre>function_name()</pre>

### 返回：将值与控件一起返回给调用者
- NOTE
<pre>语法
return_type function_name(){  
   //statements  
   return value;  
}
该 return_type 可以是任何有效的数据类型。
在 return 语句是可选的。我没有指定函数返回null;
返回值的数据类型必须与函数的返回类型匹配。
函数最多可以返回一个值。换句话说，每个函数只能有一个return语句。</pre>

### 参数：将值传递给函数的机制
- NOTE
<pre>参数构成函数签名的一部分。参数值在调用期间传递给函数。除非明确指定，否则传递给函数的值的数量必须与定义的参数数量相匹配</pre>

#### 必需的位置参数
- NOTE
<pre>在函数调用期间必须将值传递给所需的参数。
语法
Function_name(data_type param_1, data_type param_2[…]) {
   //statements
}</pre>

#### 可选位置参数：要指定可选的位置参数，请使用square \[\]括号。
- NOTE
<pre>语法
void function_name(param1, [optional_param_1, optional_param_2]) { }
如果可选参数未传递值，则将其设置为NULL。</pre>

#### 可选命名参数：必须在传递值时指定参数名称。Curly brace \{\}可用于指定可选的命名参数
- NOTE
<pre>与位置参数不同，必须在传递值时指定参数名称。Curly brace {}可用于指定可选的命名参数。

语法 - 声明函数
void function_name(a, {optional_param1, optional_param2}) { }
语法 - 调用函数
function_name(optional_param:value,…);</pre>

#### 有默认值的可选参数：默认情况下，还可以为函数参数指定值
- NOTE
<pre>语法
function_name(param1,{param2= default_value}) {
   //......
}</pre>

## 变量

### var：可以赋值不同类型的值

### dynamic

### final：声明一个只能赋值一个变量

### const：声明一个必须是编译时的常量

### 没有赋值的变量都会默认为null

## 运算符

### 按位运算符

#### &、|、^、～、\<\<、\>\>

### 逻辑运算符

#### &&、||、~

### 算术运算符
> align=`center`


#### \+、\-、\*、/、％

#### ~/、\-expr

#### \+\+var、var\+\+、\-\-var、var\-\-

### 相等和关系运算符

#### ==、\!=、\>、\<、\>=、\<=

### 赋值运算符

#### ==、??=

#### \+=、\-=、\*=、/=、%=、~/=

#### «=、»=、»=、»=、| =、^ =

### 类型测试运算符

#### is、is\!

### 条件表达式

#### 三目运算符:条件?expr1:expr2

#### ??运算符: expr1??表达式2

## 表达式和代码块
> leftSide=`true`


## 判断和循环结构
> leftSide=`true`


### 判断

#### if

##### if

##### if\.\.\.else if

##### if\.\.\.else if\.\.\.else

#### switch\.\.\.case
- NOTE
<pre>以下规则适用于switch语句
1.switch中可以有任意数量的case语句。
2.case语句只能包含常量。它不能是变量或表达式。
3.variable_expression和常量表达式的数据类型必须匹配。
4.除非你在每个代码块之后放置一个中断，否则执行会流入下一个块。
5.case表达式必须是唯一的。
6.默认块是可选的。</pre>

##### 比较类型:num、String、编译期常量、对象、枚举等

##### 非空case必须有一个break

##### default处理默认标签

##### continue跳转标签

### 循环

#### for

##### for\(\)循环
- NOTE
<pre>for 循环是一个明确循环次数的循环实现。在 for 循环执行用于指定次数的代码块。它可用于迭代一组固定的值，例如数组。

以下是 for 循环的语法。

for (initial_count_value; termination-condition; step) {
   //statements
}</pre>

##### for\.\.\.in循环
- NOTE
<pre>for ... in循环用于循环对象的属性。

以下是for ... in循环的语法。

for (variablename in object){  
   statement or block to execute  
}
在每次迭代中，来自对象的一个​​属性被分配给变量名称，并且此循环继续，直到对象的所有属性都用完为止。</pre>

#### while

##### while循环
- NOTE
<pre>while 循环执行指令指定的每个条件计算为真时。换句话说，循环在执行代码块之前评估条件。

下图显示了 while 循环的流程图

while 循环

以下是 while 循环的语法。

while (expression) {
   Statement(s) to be executed if expression is true  
}</pre>

##### do\.\.\.while循环

#### 控制

##### break终止循环

##### continue跳出当前循环

## 数据结构表示：集合/泛型

### list
- NOTE
<pre>List只是一组有序的对象。该 dart:core 库提供的列表类，使创建和列表的操作。

Dart中的列表可归类为

固定长度列表 - 列表的长度在运行时不能更改。

可增长列表 - 列表的长度可以在运行时更改。</pre>

### Set
- NOTE
<pre>Set表示对象的集合，其中每个对象只能出现一次。dart:core库提供了Set类来实现相同的功能。

语法
Identifier = new Set()
或者

Identifier = new Set.from(Iterable)
其中， Iterable 表示要添加到Set的值列表。</pre>

### Map
- NOTE
<pre>Map对象是一个简单的键/值对。地图中的键和值可以是任何类型。地图是动态集合。换句话说，Maps可以在运行时增长和缩小。dart:core库中的Map类提供了对它的支持。</pre>

### Queue
- NOTE
<pre>队列是一个可以在两端操作的集合。当您想要构建先进先出集合时，队列非常有用。简而言之，队列从一端插入数据并从另一端删除。按插入顺序删除/读取值。

语法：创建队列
Identifier = new Queue()
add()函数可用于将值插入队列。此函数将指定的值插入队列末尾。以下示例说明了相同的内容。</pre>

## 类型定义
> leftSide=`true`


### 数值型\-Number

#### 整型\-int:表示整数

#### 浮点型\-double:双精度

#### 常用运算符:\+、\-、\*、/、~/、%

#### parse\(\) 静态函数允许将字符串解析为整型

#### 常用属性

##### 常用属性:hashcode、isFinite、isInfinite、isNan、isNegative、sign、isEven、ISODD

#### 常用方法

##### 常用方法:ABS、ceil、compareTo、Floor、remainder、Round、toDouble、toInt、toString、truncate

### 字符型\-String

#### 字符串是一系列UTF 16代码单元

#### 常用运算符：\+、\*、==、\[\]

#### 插值表达式：$\(expression\)

#### 常用属性：CODEUNITS、isEmpty、Length

#### 常用方法：toLowerCase\(\)、toUpperCase\(\)、trim\(\)、compareTo\(\)、replaceAll\(\)、split\(\)、substring\(\)、toString\(\)、codeUnitAt\(\)

#### 创建

##### 使用单引号、双引号创建字符串

##### 使用三引号、双引号创建多行字符串

##### 使用r创建原始raw字符串

### 布尔型\-Boolean

#### 两个值true和false

#### 使用bool表示

### 列表\-list

#### 创建

##### 使用\[\]创建：var list=\[1,2,3\]

##### 使用const创建不可变:var list = const\[1,2,3\]

##### 使用构造new创建:var list=new list\(\)

#### 常用操作:\[\]、add\(\)、insert\(\)、remove\(\)、clear\(\)、sort\(\)、forEach\(\)

#### 属性：first、isEmpty、isNotEmpty、length、last、reversed、Single

### 健值对\-map

#### 创建

##### 使用\{\}创建：var map = \{'key','value'\}

##### 使用const创建不可变：var map = const\{'key','value'\}

##### 使用new创建:var map = new map\(\)

#### 常用操作：\[\]、addAll\(\)、clear\(\)、remove\(\)、forEach\(\)

#### 属性：Keys、Values、Length、isEmpty、isNotEmpty

### dynamic

#### 没有明确的类型

## 注释
> leftSide=`true`


### //、/\*\* \*/、///

### ///注释文档，多行使用

## 异常
> leftSide=`true`

- NOTE
<pre>1.DeferredLoadException
延迟库无法加载时抛出。
2.FormatException
当字符串或某些其他数据不具有预期格式且无法解析或处理时抛出异常。
3.IntegerDivisionByZeroException
当数字除以零时抛出。
4.IOException异常
所有与Inupt-Output相关的异常的基类。
5.IsolateSpawnException
无法创建隔离时抛出。
6.Timeout
在等待异步结果时发生计划超时时抛出。</pre>

### dart会抛出并捕获异常，如果没有捕获异常，就会中断程序运行

### Exception、Error

#### 内置

#### 自定义

### try/on/catch块
- NOTE
<pre>try{
   // code that might throw an exception
}
on Exception1{
   // exception handling code
}
catch Exception2 {
   //  exception handling
}
finally{
   // code that should always execute; irrespective of the exception
}</pre>

#### on:指定异常类型
- NOTE
<pre>1.DeferredLoadException
延迟库无法加载时抛出。
2.FormatException
当字符串或某些其他数据不具有预期格式且无法解析或处理时抛出异常。
3.IntegerDivisionByZeroException
当数字除以零时抛出。
4.IOException异常
所有与Inupt-Output相关的异常的基类。
5.IsolateSpawnException
无法创建隔离时抛出。
6.Timeout
在等待异步结果时发生计划超时时抛出。</pre>

#### catch:处理程序需要异常对象块

#### finally:应该执行无关的异常的发生的代码\.确保代码的运行，最终都会执行finally语句

### throw:处理引发的异常，以防止程序突然退出

## 库和包
> leftSide=`true`


### Dart库由一组类，常量，函数，typedef，属性和异常组成。

### 导入

#### 其他库

##### 文件系统路径

##### package:scheme

#### 内置库
- NOTE
<pre>1.dart:io
服务器应用程序的文件，套接字，HTTP和其他I / O支持。此库在基于浏览器的应用程序中不起作用。默认情况下导入此库。
2.dart:core
每个Dart程序的内置类型，集合和其他核心功能。该库是自动导入的。
3.dart:math
数学常数和函数，加上随机数生成器。
4.dart::convert
用于在不同数据表示之间进行转换的编码器和解码器，包括JSON和UTF-8。
5.dart:typed_data
有效处理固定大小数据的列表(例如，无符号8字节整数)。
</pre>

##### dart:scheme

#### 使用库的一部分
- NOTE
<pre>import 'package: lib1/lib1.dart' show foo, bar;  
// 只导入foo 和 bar.
import 'package: mylib/mylib.dart' hide foo;  
// 导入除了foo的所有</pre>

##### show:指定导入的函数

##### hide:指定不需要导入的函数

### 封装库：使用下划线\(\_\)为标识符添加前缀，以将其组件标记为私有
- NOTE
<pre>语法
_identifier</pre>

### 自定义库

#### 声明：library library\_name

#### 关联：同一目录: import 'library\_name'     不同的目录: import 'dir/library\_name'

### as: 导入两个具有冲突标识符的库，则可以为一个或两个库指定前缀。使用 'as' 关键字指定前缀

### export:导出库
- NOTE
<pre>关键字导出一个更大的库
library math;
export 'random.dart';
export 'point.dart';

导出部分组合成一个新库
library math;
export 'random.dart' show Random;
export 'point.dart' hide Sin;</pre>

### 利用Pub管理自己的库

## 其他

### Typedef
- NOTE
<pre>第1步：定义typedef
一个 typedef 可以用来指定我们要匹配的函数签名。函数签名由函数的参数(包括其类型)定义。返回类型不是函数签名的一部分。其语法如下。
typedef function_name(parameters)
第2步：将函数分配给typedef变量
的可变 typedef 可以指向具有相同签名的任何函数 typedef 。您可以使用以下签名将函数分配给 typedef 变量。
type_def  var_name = function_name
第3步：调用函数
typedef 变量可以用于调用函数。以下是调用函数的方法
var_name(parameters)</pre>

#### typedef 或函数型的别名，有助于存储器内定义指针的可执行代码，简单地说， typedef 可以用作引用函数的指针

### 泛型：强制限制集合可以包含的值的数据类型
- NOTE
<pre>语法
Collection_name &lt;data_type&gt; identifier= new Collection_name&lt;data_type&gt;</pre>

### 序列
- NOTE
<pre>序号	dart集合和描述
1.List
List只是一组有序的对象。该dart:core库提供的列表类，使创建和列表的操作。
固定长度列表 - 列表的长度在运行时不能更改。
可变长度列表 - 列表的长度可以在运行时更改。
2.Set
Set表示对象的集合，其中每个对象只能出现一次。`dart:core`库提供了Set类来实现相同的功能。
3.Maps
Map对象是一个简单的键/值对。地图中的键和值可以是任何类型。Map是动态集合。换句话说，Maps可以在运行时增长和缩小。`dart:core`库中的Map类提供了对它的支持。
4.Queue
队列是一个可以在两端操作的集合。当您想要构建先进先出集合时，队列非常有用。简而言之，队列从一端插入数据并从另一端删除。按插入顺序删除/读取值。</pre>

### 对象:具有已定义边界的任何实体
- NOTE
<pre>面向对象编程将对象定义为 具有已定义边界的任何实体 。对象具有以下内容
状态 - 描述对象。 类的字段表示对象的状态。
行为 - 描述对象可以执行的操作。
标识 - 区分对象与一组类似其他对象的唯一id值。 两个或多个对象可以共享状态和行为，但不能共享身份。
句点运算符 (.) 与对象一起使用以访问类的数据成员。</pre>

#### 级联操作符\(\.\.\)

#### toString\(\)方法

### 接口

#### 定义了一组对象可用的方法
- NOTE
<pre>语法：实现接口
class identifier implements interface_name</pre>

#### 实现多个接口
- NOTE
<pre>一个类可以实现多个接口。接口用逗号分隔。下面给出了相同的语法
class identifier implements interface-1,interface_2,interface_4…….</pre>

#### 应该使用implements关键字来使用接口。实现类必须提供已实现接口的所有功能的具体实现。换句话说，类必须重新定义它希望实现的接口中的每个函数。

### 枚举
- NOTE
<pre>语法
enum enum_name {  
   enumeration list
}
enum_name 指定枚举类型名称
enumeration list 是一个逗号分隔的标识符的列表</pre>

### 编码

### 符号

### 调试

### 异步

#### 从执行主应用程序线程中分出来，在一个单独线程中执行

#### Future对象是一种表示由表达式返回的值的机制，该表达式的执行将在稍后的时间点完成。

#### 异步操作可让您的程序运行而不会被阻止。Dart使用 Future对象 来表示异步操作。

### 并发
- NOTE
<pre>并发是同时执行多个指令序列。它涉及同时执行多个任务。
Dart使用 Isolates作为并行工作的工具。dart:isolate是dart的解决方案，以单线程dart代码，并允许应用程序更好地利用现有的硬代码。
隔离，顾名思义，是运行代码的独立单元。在它们之间发送数据的唯一方法是传递消息，就像在客户端和服务器之间传递消息的方式一样。一个 分离 有助于程序充分利用多核微处理器的开箱即用。</pre>

#### 同时执行多个指令序列

#### Isolates作为并行工作的工具。dart:isolate是dart的解决方案，

#### 隔离区与线程的不同之处在于隔离区有自己的内存。没有办法在隔离区之间共享变量\-隔离区之间通信的唯一方法是通过消息传递。

#### Isolate vs Future
- NOTE
<pre>异步执行复杂的计算工作对于确保应用程序的响应性非常重要。 Dart Future 是一种在完成后检索异步任务的值的机制，而 Dart Isolates 是一种抽象并行性并在实际的高级基础上实现它的工具。</pre>

### 单元测试

#### 步骤

##### 第1步：安装“test”包

##### 第2步：导入“test”包

##### 第3步编写测试

#### 测试用例

#### 分组测试用例

### HTML DOM
